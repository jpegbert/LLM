[TOC]

在人工智能快速发展的当下，大语言模型（LLM）技术取得了显著进步，但也面临诸多挑战。检索增强生成（RAG）技术应运而生，为提升语言模型性能提供了新途径。不过，传统 RAG 存在一定局限，而 Agentic RAG 则试图突破这些瓶颈，带来更强大的功能体验。本文将探究二者的差异。

# 1. 传统 RAG 的困境

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/SaeK9tW7Buib02aUGlGKOTroKic46Sa1or53A4fBvpPTiaZv0gcx6LPySZFLbeAtXUFywz1L6MsqIEGY7XZ3Kgic3Q/640?wx_fmt=gif&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

传统 RAG 的工作流程主要包括：先将文档进行编码，通过嵌入模型转化为向量形式存储在数据库中。当接收到用户查询时，对查询进行编码，然后在数据库中进行相似度搜索，找到最相似的文档，将其作为上下文信息与查询一起构建提示（Prompt），最后输入到 LLM 中生成回答。看似流畅的流程，却隐藏着不少问题。

- **单次检索生成的局限**：传统 RAG 仅进行一次检索和生成。在实际应用中，如果初始检索到的上下文信息不足，它无法根据需求动态搜索更多信息。比如，当用户询问一个涉及多领域交叉的复杂问题时，一次检索获取的内容可能只是问题的冰山一角，难以全面准确地回答问题。
- **推理能力短板**：面对复杂查询，传统 RAG 在推理方面显得力不从心。像一些需要逻辑推导、多步分析的问题，它无法像人类一样进行深入思考和推理，只能简单地匹配和组合已有信息，导致回答质量不高。
- **缺乏策略调整能力**：传统 RAG 系统缺乏自适应能力，无论面对何种问题，都采用固定的处理方式，无法根据问题的类型、复杂程度等因素灵活调整策略，难以满足多样化的用户需求。

# 2. Agentic RAG 的创新突破

Agentic RAG 旨在解决传统 RAG 的上述问题，其核心思想是在 RAG 的各个阶段引入智能化（Agentic）行为，通过智能代理（LLM Agent）来优化整个流程。下面结合其具体步骤来深入了解：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_gif/SaeK9tW7Buib02aUGlGKOTroKic46Sa1orFMvJecMYkpWGGibeswdw4mQYBJWTIsF7z4Ioiaj6NllvgG7rqQueD7SA/640?wx_fmt=gif&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- **查询重写优化（第 1 - 2 步）**：当用户查询输入后，智能代理首先对初始查询进行重写。这一过程不仅可以纠正拼写错误，还能对模糊、歧义的表述进行澄清，将用户的意图转化为更精准的查询语句，为后续获取更准确的信息奠定基础。例如，用户输入 “苹果的最新产品有那些”，智能代理可能会将其重写为 “苹果公司 2024 年发布的最新产品有哪些”，明确了时间范围和主体，提高查询的准确性。
- **上下文信息智能判断（第 3 - 8 步）**：重写后的查询进入判断环节，智能代理会评估是否需要更多上下文信息。若判断不需要，重写后的查询会直接发送给 LLM。如果需要，代理会从多种外部来源（如数据库向量、工具和 API、互联网等）中寻找最佳的上下文信息，并传递给 LLM。比如，当用户询问 “如何制作低糖蛋糕” 时，代理会从专业的美食数据库、烹饪工具 API 或互联网上的美食论坛中获取相关的低糖蛋糕制作配方、技巧等信息，补充丰富的上下文，帮助 LLM 生成更优质的回答。
- **响应生成与检查（第 9 - 12 步）**：LLM 根据接收到的查询和上下文信息生成回答后，智能代理会对答案进行检查，判断其是否与问题相关。如果答案相关，就直接返回给用户；若不相关，则返回第一步重新开始整个流程。这一循环会多次执行，直到得到合适的回答，或者系统判断无法回答该查询。通过不断的反馈和优化，确保回答与用户问题高度契合，提升回答的准确性和相关性。

# 3. Agentic RAG 的优势与应用前景

相比传统 RAG，Agentic RAG 通过引入智能代理，在处理复杂任务和多样化需求时表现得更加健壮和灵活。它能够根据问题动态调整策略，不断优化回答，为用户提供更满意的服务。

在实际应用中，无论是智能客服领域，帮助客服快速准确地回答用户复杂问题；还是在智能写作辅助场景，为创作者提供丰富的素材和精准的建议；亦或是在教育领域，实现个性化的智能辅导，Agentic RAG 都有着巨大的潜力，有望成为推动人工智能应用进一步发展的重要力量。

需要注意的是，文中展示的 Agentic RAG 架构只是众多架构中的一种，在不同的使用场景下，开发者可以根据实际需求对其进行灵活调整和适配，以发挥出最大的效能。